---
description: Defines the 4-stage lifecycle for model classes - experimental, production, pre-deprecation, and deprecation - ensuring structured development and backward compatibility.
alwaysApply: false
---

When creating or moving model classes, rule MOD-002 must be followed.
Explicitly reference "Following rule MOD-002" and state which lifecycle stage
applies. For example: "Following rule MOD-002, which states that new model classes should start in the experimental stage, and that new model classes should go in physicsnemo/experimental/models/, this new model should start in
physicsnemo/experimental/models/..."

## MOD-002: Model classes lifecycle

**Description:**
All model classes must follow the following lifecycle:

- Stage 1: Creation. This is the stage where the model class is created. For
  the vast majority of models, new classes are created either in
  `physicsnemo/experimental/nn` for reusable layers, or in
  `physicsnemo/experimental/models` for more complete models. The `experimental`
  folder is used to store models that are still under development (beta or
  alpha releases) during this stage, backward compatibility is not guaranteed.
  One exception is when the developer is highly confident that the model
  is sufficiently mature and applicable to many domains or use cases. In this
  case the model class can be created in the `physicsnemo/nn` or `physicsnemo/models`
  folders directly, and backward compatibility is guaranteed. Another exception
  is when the model class is highly specific to a single example. In this case,
  it may be acceptable to place it in a module specific to the example code,
  such as for example `examples/<example_name>/utils/nn.py`.

- Stage 2: Production. After staying in stage 1 for a sufficient amount of time
  (typically at least 1 release cycle), the model class is promoted to stage 2.
  It is then moved to the `physicsnemo/nn` or `physicsnemo/models` folders,
  based on the rule `MOD-000`. During this stage, backward compatibility is
  guaranteed. Note that a model is not allowed to be promoted to stage 2
  without the CI tests required by rule MOD-008.

- Stage 3: Pre-deprecation. For a model class in stage 3 in `physicsnemo/nn` or
  `physicsnemo/models`, the developer should start planning its deprecation.
  This is done by adding a warning message to the model class, indicating that
  the model class is deprecated and will be removed in a future release. The
  warning message should be a clear and concise message that explains why the
  model class is being deprecated and what the user should do instead. The
  deprecation message should be added to both the docstring and should be
  raised at runtime. The developer is free to choose the mechanism to raise the
  deprecation warning. A model class cannot be deprecated without staying in
  stage 3 "pre-deprecation" for at least 1 release cycle.

- Stage 4: Deprecation. After staying in stage 3 "pre-deprecation" for at least 1
  release cycle, the model class is deprecated. It can be deleted from the
  codebase.

**Rationale:**
This lifecycle ensures a structured approach to model development and maintenance.
The experimental stage allows rapid iteration without backward compatibility
constraints, enabling developers to refine APIs based on user feedback. The
production stage provides stability for users who depend on these models. The
pre-deprecation and deprecation stages ensure users have sufficient time to
migrate to newer alternatives, preventing breaking changes that could disrupt
their workflows. This graduated approach balances innovation with stability,
a critical requirement for a scientific computing framework.

**Example:**

```python
# Good: Stage 1 - New experimental model
# File: physicsnemo/experimental/models/new_diffusion.py
class DiffusionModel(Module):
    """New diffusion model under active development. API may change."""
    pass

# Good: Stage 2 - Promoted to production after 1 release cycle
# File: physicsnemo/models/diffusion.py (moved from experimental/)
class DiffusionModel(Module):
    """Stable diffusion model with backward compatibility guarantees."""
    pass

# Good: Stage 3 - Pre-deprecation with warning
# File: physicsnemo/models/old_diffusion.py
class DiffusionModel(Module):
    """
    Legacy diffusion model.

    .. deprecated:: 0.5.0
        ``OldDiffusionModel`` is deprecated and will be removed in version 0.7.0.
        Use :class:`~physicsnemo.models.NewDiffusionModel` instead.
    """
    def __init__(self):
        import warnings
        warnings.warn(
            "OldDiffusionModel is deprecated. Use DiffusionModel instead.",
            DeprecationWarning,
            stacklevel=2
        )
        super().__init__()

# Good: Stage 4 - Model removed after deprecation period
# (File deleted from codebase)
```

**Anti-pattern:**

```python
# WRONG: New model directly in production folder without experimental phase
# File: physicsnemo/models/brand_new_model.py (should be in experimental/ first)
class BrandNewModel(Module):
    """Skipped experimental stage - risky for stability"""
    pass

# WRONG: Breaking changes in production without deprecation cycle
# File: physicsnemo/models/diffusion.py
class DiffusionModel(Module):
    def __init__(self, new_required_param):  # Breaking change!
        # Changed API without deprecation warning - breaks user code
        pass

# WRONG: Deprecation without sufficient warning period
# (Model deprecated and removed in same release)

# WRONG: No deprecation warning in code
# File: physicsnemo/models/old_model.py
class OldModel(Module):
    """Will be removed next release."""  # Docstring mentions it but no runtime warning
    def __init__(self):
        # Missing: warnings.warn(..., DeprecationWarning)
        super().__init__()
```
